[
  {
    "objectID": "sessions/05_rlang.html",
    "href": "sessions/05_rlang.html",
    "title": "tidyverseとrlangを組み合わせる",
    "section": "",
    "text": "これまで、tidyverseの各パッケージで利用可能な関数について紹介してきました。最期に、tidyverseの関数を組み合わせて独自の関数を定義する際に覚えておくと捗る、rlangパッケージとの連携を導入します。\nrlangとは、R言語におけるプログラミングのためのフレームワークとAPIを提供するパッケージの一種です。\n\nlibrary(palmerpenguins)\n\n\nmtcars |&gt; \n  count(gear) |&gt; \n  ggplot() +\n  aes(gear, n) +\n  geom_bar(stat = \"identity\")\n\ndiamonds |&gt; \n  count(cut) |&gt; \n  ggplot() +\n  aes(cut, n) +\n  geom_bar(stat = \"identity\")\n\npenguins |&gt; \n  count(species) |&gt; \n  ggplot() +\n  aes(species, n) +\n  geom_bar(stat = \"identity\")\n\n\nmy_barplot &lt;- function(data, var) {\n  data |&gt; \n  count(var) |&gt; \n  ggplot() +\n  aes(var, n) +\n  geom_bar(stat = \"identity\")\n}\n\n\nmy_barplot(mtcars, gear)\n\nError in `count()`:\n! Must group by variables found in `.data`.\n✖ Column `var` is not found.\n\n\n{{ (カリーカリー)演算子\n\nmy_barplot &lt;- function(data, var) {\n  data |&gt; \n  count({{ var }}) |&gt; \n  ggplot() +\n  aes({{ var }}, n) +\n  geom_bar(stat = \"identity\")\n}\n\nmy_barplot(mtcars, gear)\n\n\nmy_barplot(diamonds, cut)\nmy_barplot(penguins, species)\n\n\nmy_barplot &lt;- function(data, var) {\n  data |&gt; \n  count({{ var }}) |&gt; \n  ggplot() +\n  aes({{ var }}, n) +\n  geom_bar(stat = \"identity\")\n}\n\n\npenguins |&gt; \n  count(species) |&gt; \n  mutate(species = fct_reorder(species, n)) |&gt; \n  ggplot() +\n  aes(species, n) +\n  geom_bar(stat = \"identity\")\n\n:=\n\nmy_barplot2 &lt;- function(data, var, ...) {\n  data |&gt; \n    count({{ var }}) |&gt; \n    mutate({{ var }} := fct_reorder({{ var }}, n)) |&gt; \n    ggplot() +\n    aes({{ var }}, n, fill = {{ var }}) +\n    geom_bar(stat = \"identity\",\n             show.legend = FALSE,\n             ...)\n}\n\nmy_barplot2(penguins, species)\nmy_barplot2(penguins, species, fill = \"tomato\")\n\n\nlibrary(jmastats)\n\ncrossing(year = seq.int(2020, 2022),\n         month = seq.int(7, 9),\n         block_no = c(\"47895\", \"47891\", \"47887\", \"47893\")) |&gt;\n      purrr::pmap(\n        function(block_no, year, month, ...) {\n          jmastats::jma_collect(item = \"monthly\",\n                                block_no = {{ block_no }},\n                                year = {{ year }},\n                                month = {{ month }}) |&gt;\n            dplyr::mutate(block_no = {{ block_no }})\n        }\n      ) |&gt;\n      dplyr::bind_rows()"
  },
  {
    "objectID": "sessions/03_purrr.html",
    "href": "sessions/03_purrr.html",
    "title": "purrr",
    "section": "",
    "text": "purrr（読み方は、「ぷりゃー」、「ぷるるる」等さまざま）パッケージは、Rの関数型プログラミングを支援するパッケージです。関数型プログラミングでは、関数を引数として渡すことで、複数の関数を組み合わせてプログラムを構築します。\npurrrパッケージの利点の一つは、関数を繰り返し実行するコードを簡潔に書き換え可能な点です。例えば、以下のコードは、map()関数を使って、mtcarsデータセットの各列の平均値を計算しています。\n\nmtcars |&gt; \n  map(mean)\n\n$mpg\n[1] 20.09062\n\n$cyl\n[1] 6.1875\n\n$disp\n[1] 230.7219\n\n$hp\n[1] 146.6875\n\n$drat\n[1] 3.596563\n\n$wt\n[1] 3.21725\n\n$qsec\n[1] 17.84875\n\n$vs\n[1] 0.4375\n\n$am\n[1] 0.40625\n\n$gear\n[1] 3.6875\n\n$carb\n[1] 2.8125\n\n\npurrrを使わずに同様の処理を実行することももちろん可能です。しかしpurrrには、以下の表に示すようにたくさんの関数が用意されており、目的に応じて関数を使い分けることで、コードの保守性を高めることに貢献します。\n\n\n\n\n\n\n\n\n\n\n与える引数の数\n返り値がリスト\n返り値がベクトル\n返り値が入力と同じ型\n返り値なし\n\n\n\n\n一つ\nmap()\nmap_lgl(), map_chr(), map_dbl(), map_int()\nmodify()\nwalk()\n\n\n二つ\nmap2()\nmap2_lgl(), map2_chr(), map2_dbl(), map2_int()\nmodify2()\nwalk2()\n\n\n一つ + インデックス\nimap()\nimap_lgl(), imap_chr(), imap_dbl(), imap_int()\nimodify()\niwalk()\n\n\n任意\npmap()\npmap_lgl(), pmap_chr(), pmap_dbl(), pmap_int()\n-\npwalk()\n\n\n\n\n\n\n\n\nmap(c(1, 3, 5), \\(x) x + 1)\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n\n\ntibble(\n  x = c(1, 3, 5)) |&gt;\n  map(\\(x) x + 1)\n\n$x\n[1] 2 4 6\n\ntibble(\n    x = c(1, 3, 5)) |&gt;\n    modify(\\(x) x + 1)\n\n\n\n\n\nx\n\n\n\n\n2\n\n\n4\n\n\n6\n\n\n\n\n\n\n\ntibble(\n    x = c(\"a\", \"b\", \"c\"),\n    y = c(\"D\", \"E\", \"F\")) |&gt; \n    map2(\\(x, y) paste0(x, y))\n\nError in `map2()`:\n! `.y` must be a vector, not a function.\n\n\n\ntibble(\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(\"D\", \"E\", \"F\")) |&gt; \n  pmap(\\(x, y) paste0(x, y))\n\n[[1]]\n[1] \"aD\"\n\n[[2]]\n[1] \"bE\"\n\n[[3]]\n[1] \"cF\"\n\n\n\ntibble::tibble(\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(\"D\", \"E\", \"F\")) %&gt;%\n  mutate(z = pmap_chr(., \\(x, y) paste0(x, y)))\n\n\n\n\n\nx\ny\nz\n\n\n\n\na\nD\naD\n\n\nb\nE\nbE\n\n\nc\nF\ncF\n\n\n\n\n\ntibble(\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(\"D\", \"E\", \"F\")) %&gt;%\n  mutate(z = pmap(., \\(x, y) paste0(x, y))) |&gt; \n  unnest(cols = z)\n\n\n\n\n\nx\ny\nz\n\n\n\n\na\nD\naD\n\n\nb\nE\nbE\n\n\nc\nF\ncF\n\n\n\n\n\n\nプログレスバー\n\n36:39 |&gt; \n  purrr::map(jpmesh::administration_mesh, \n             to_mesh_size = 10, \n             .progress = TRUE)\n\n\nerrors … 何番目の要素に問題があるか\n\n\nlist(1, 2, \"c\") |&gt; \n  purrr::map(\\(x) x + 1)\n\nError in `purrr::map()`:\nℹ In index: 3.\nCaused by error in `x + 1`:\n! non-numeric argument to binary operator\n\n\n\nseq.int(3) |&gt; \n  map(\\(x) factor(letters[x]))\n\n[[1]]\n[1] a\nLevels: a\n\n[[2]]\n[1] b\nLevels: b\n\n[[3]]\n[1] c\nLevels: c\n\n\n\nseq.int(3) |&gt; \n  map_vec(\\(x) factor(letters[x]))\n\n[1] a b c\nLevels: a b c\n\n\n\nx &lt;- list(a = 1, b = 2, c = 3, D = 4, E = 5)\n\nx |&gt; \n  keep_at(c(\"a\", \"b\", \"c\")) |&gt; \n  str()\n\nList of 3\n $ a: num 1\n $ b: num 2\n $ c: num 3\n\nx |&gt; \n  keep_at(function(x) x == tolower(x)) |&gt; \n  str()\n\nList of 3\n $ a: num 1\n $ b: num 2\n $ c: num 3\n\nx |&gt; \n  discard_at(c(\"a\", \"b\", \"c\")) |&gt; \n  str()\n\nList of 2\n $ D: num 4\n $ E: num 5"
  },
  {
    "objectID": "sessions/03_purrr.html#データフレーム中でmapを使う",
    "href": "sessions/03_purrr.html#データフレーム中でmapを使う",
    "title": "purrr",
    "section": "",
    "text": "map(c(1, 3, 5), \\(x) x + 1)\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n\n\ntibble(\n  x = c(1, 3, 5)) |&gt;\n  map(\\(x) x + 1)\n\n$x\n[1] 2 4 6\n\ntibble(\n    x = c(1, 3, 5)) |&gt;\n    modify(\\(x) x + 1)\n\n\n\n\n\nx\n\n\n\n\n2\n\n\n4\n\n\n6\n\n\n\n\n\n\n\ntibble(\n    x = c(\"a\", \"b\", \"c\"),\n    y = c(\"D\", \"E\", \"F\")) |&gt; \n    map2(\\(x, y) paste0(x, y))\n\nError in `map2()`:\n! `.y` must be a vector, not a function.\n\n\n\ntibble(\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(\"D\", \"E\", \"F\")) |&gt; \n  pmap(\\(x, y) paste0(x, y))\n\n[[1]]\n[1] \"aD\"\n\n[[2]]\n[1] \"bE\"\n\n[[3]]\n[1] \"cF\"\n\n\n\ntibble::tibble(\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(\"D\", \"E\", \"F\")) %&gt;%\n  mutate(z = pmap_chr(., \\(x, y) paste0(x, y)))\n\n\n\n\n\nx\ny\nz\n\n\n\n\na\nD\naD\n\n\nb\nE\nbE\n\n\nc\nF\ncF\n\n\n\n\n\ntibble(\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(\"D\", \"E\", \"F\")) %&gt;%\n  mutate(z = pmap(., \\(x, y) paste0(x, y))) |&gt; \n  unnest(cols = z)\n\n\n\n\n\nx\ny\nz\n\n\n\n\na\nD\naD\n\n\nb\nE\nbE\n\n\nc\nF\ncF\n\n\n\n\n\n\nプログレスバー\n\n36:39 |&gt; \n  purrr::map(jpmesh::administration_mesh, \n             to_mesh_size = 10, \n             .progress = TRUE)\n\n\nerrors … 何番目の要素に問題があるか\n\n\nlist(1, 2, \"c\") |&gt; \n  purrr::map(\\(x) x + 1)\n\nError in `purrr::map()`:\nℹ In index: 3.\nCaused by error in `x + 1`:\n! non-numeric argument to binary operator\n\n\n\nseq.int(3) |&gt; \n  map(\\(x) factor(letters[x]))\n\n[[1]]\n[1] a\nLevels: a\n\n[[2]]\n[1] b\nLevels: b\n\n[[3]]\n[1] c\nLevels: c\n\n\n\nseq.int(3) |&gt; \n  map_vec(\\(x) factor(letters[x]))\n\n[1] a b c\nLevels: a b c\n\n\n\nx &lt;- list(a = 1, b = 2, c = 3, D = 4, E = 5)\n\nx |&gt; \n  keep_at(c(\"a\", \"b\", \"c\")) |&gt; \n  str()\n\nList of 3\n $ a: num 1\n $ b: num 2\n $ c: num 3\n\nx |&gt; \n  keep_at(function(x) x == tolower(x)) |&gt; \n  str()\n\nList of 3\n $ a: num 1\n $ b: num 2\n $ c: num 3\n\nx |&gt; \n  discard_at(c(\"a\", \"b\", \"c\")) |&gt; \n  str()\n\nList of 2\n $ D: num 4\n $ E: num 5"
  },
  {
    "objectID": "sessions/01_dplyr.html",
    "href": "sessions/01_dplyr.html",
    "title": "dplyr",
    "section": "",
    "text": "dplyrパッケージは主にデータフレームを対象としたデータ加工のための関数を提供します。データ加工のための操作にはいくつかの種類がありますが、dplyrパッケージではこれらの操作を個別の関数として提供しています。dplyrパッケージの関数を組み合わせて利用することで、データ加工の処理を効率的に行うことができます。\ndplyrが対象とするデータ操作の種類としては、次のようなものがあります。\n\nデータの選択・絞り込み… select(), filter()\nデータの並べ替え… arrange()\nデータの加工… mutate()\nデータの集約… summarise(), count()\nデータの結合… *_join(), bind_*()\n\ndplyrはこのほか、データフレーム全体ではなく、データの値、すなわちベクトルに対する操作を行うcase_when()関数、if_else()関数、na_if()関数など、いくつも備わっています。\nデータ操作を行う上でdplyrパッケージの関数は直感的にわかりやすいため、dplyrの関数をデータベース上のデータに適用したり、data.tableクラスのオブジェクトに対して適用可能にするパッケージも用意されています。"
  },
  {
    "objectID": "sessions/01_dplyr.html#dplyr速習",
    "href": "sessions/01_dplyr.html#dplyr速習",
    "title": "dplyr",
    "section": "",
    "text": "dplyrパッケージは主にデータフレームを対象としたデータ加工のための関数を提供します。データ加工のための操作にはいくつかの種類がありますが、dplyrパッケージではこれらの操作を個別の関数として提供しています。dplyrパッケージの関数を組み合わせて利用することで、データ加工の処理を効率的に行うことができます。\ndplyrが対象とするデータ操作の種類としては、次のようなものがあります。\n\nデータの選択・絞り込み… select(), filter()\nデータの並べ替え… arrange()\nデータの加工… mutate()\nデータの集約… summarise(), count()\nデータの結合… *_join(), bind_*()\n\ndplyrはこのほか、データフレーム全体ではなく、データの値、すなわちベクトルに対する操作を行うcase_when()関数、if_else()関数、na_if()関数など、いくつも備わっています。\nデータ操作を行う上でdplyrパッケージの関数は直感的にわかりやすいため、dplyrの関数をデータベース上のデータに適用したり、data.tableクラスのオブジェクトに対して適用可能にするパッケージも用意されています。"
  },
  {
    "objectID": "sessions/01_dplyr.html#データの用意",
    "href": "sessions/01_dplyr.html#データの用意",
    "title": "dplyr",
    "section": "データの用意",
    "text": "データの用意\ndplyrパッケージを使って行う処理を説明するために、南極に生育するペンギン個体の各部位の大きさについてのデータを利用します。このデータ（penguins）は次のパッケージの読み込みと同時に利用できるようになります。\n\nlibrary(palmerpenguins)\n\n\npenguins |&gt; \n  slice_head(n = 6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\nAdelie\nTorgersen\n39.1\n18.7\n181\n3750\nmale\n2007\n\n\nAdelie\nTorgersen\n39.5\n17.4\n186\n3800\nfemale\n2007\n\n\nAdelie\nTorgersen\n40.3\n18.0\n195\n3250\nfemale\n2007\n\n\nAdelie\nTorgersen\nNA\nNA\nNA\nNA\nNA\n2007\n\n\nAdelie\nTorgersen\n36.7\n19.3\n193\n3450\nfemale\n2007\n\n\nAdelie\nTorgersen\n39.3\n20.6\n190\n3650\nmale\n2007\n\n\n\n\n\n\nペンギンデータに対して、以降の処理の説明を簡略化するために、データの件数と変数を減らします。\n\nset.seed(123)\npenguins_small &lt;-\n  penguins |&gt;\n  slice_sample(n = 6) |&gt;\n  select(species, island, starts_with(\"bill\"), sex)\n\npenguins_small\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nsex\n\n\n\n\nGentoo\nBiscoe\n44.5\n14.3\nNA\n\n\nAdelie\nTorgersen\n38.6\n21.2\nmale\n\n\nGentoo\nBiscoe\n45.3\n13.7\nfemale\n\n\nChinstrap\nDream\n52.8\n20.0\nmale\n\n\nAdelie\nTorgersen\n37.3\n20.5\nmale\n\n\nChinstrap\nDream\n43.2\n16.6\nfemale\n\n\n\n\n\n\nそれではdplyrの関数を使って、このデータを加工していきましょう。"
  },
  {
    "objectID": "sessions/01_dplyr.html#複数の列への処理",
    "href": "sessions/01_dplyr.html#複数の列への処理",
    "title": "dplyr",
    "section": "複数の列への処理",
    "text": "複数の列への処理\n\nacross\n共通の処理を複数の列へ適用する場合、次のように変数 = 関数(変数)の関係を個別に指定する書き方は効率が悪いです。across()関数を使うことで、このような複数列への一括処理が容易に行えるようになります。\n\npenguins_small |&gt; \n  # stringr::str_to_upper()はアルファベット文字列を大文字に変換します\n  mutate(species = str_to_upper(species),\n            sex = str_to_upper(sex),\n         .keep = \"none\")\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGENTOO\nNA\n\n\nADELIE\nMALE\n\n\nGENTOO\nFEMALE\n\n\nCHINSTRAP\nMALE\n\n\nADELIE\nMALE\n\n\nCHINSTRAP\nFEMALE\n\n\n\n\n\n\n\n新しい書き方古い書き方\n\n\nacross()は関数を適用する列を.cols引数で指定し、適用する関数名を.fnsに渡して実行します。 次のコードはstr_to_upper()関数を2つの変数に個別に実行していたものをacross()関数を使った書き方に直したものです。\n\npenguins_small |&gt; \n  mutate(across(.cols = c(\"species\", \"sex\"), \n                   .fns = str_to_upper),\n         .keep = \"none\")\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGENTOO\nNA\n\n\nADELIE\nMALE\n\n\nGENTOO\nFEMALE\n\n\nCHINSTRAP\nMALE\n\n\nADELIE\nMALE\n\n\nCHINSTRAP\nFEMALE\n\n\n\n\n\n\n結果は出力しませんが、以下のように書くこともできます。\n\npenguins_small |&gt; \n  mutate(across(c(species, sex), \n                   str_to_upper),\n         .keep = \"none\")\npenguins_small |&gt; \n  mutate(across(c(species, sex), \n                   ~ str_to_upper(.x)),\n         .keep = \"none\")\npenguins_small |&gt; \n  mutate(across(c(species, sex), \n                   function(x) str_to_upper(x)),\n         .keep = \"none\")\npenguins_small |&gt; \n  mutate(across(c(species, sex), \n                   \\(x) str_to_upper(x)),\n         .keep = \"none\")\n\n\n\n*_all(), *_at(), *_if() で終わる関数を使って複数列への処理が可能ですが、これらの関数は2023年8月現在 superseded扱いとなっています。\n\npenguins_small |&gt; \n  transmute_at(c(\"species\", \"sex\"), \n               .funs = str_to_upper)\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGENTOO\nNA\n\n\nADELIE\nMALE\n\n\nGENTOO\nFEMALE\n\n\nCHINSTRAP\nMALE\n\n\nADELIE\nMALE\n\n\nCHINSTRAP\nFEMALE\n\n\n\n\n\n\nこの書き方に慣れている人は、関数を指定する引数名がacross()関数と異なる点に注意が必要です。 具体的にはacross(.fns = )で関数を指定することになります。\nまた、*_all(), *_at(), *_if()で利用可能だった、処理関数の第一引数以外の引数の指定方法はacross()関数では利用できません。 このあと説明する、across()関数での引数の指定方法を覚えましょう。\n\npenguins_small |&gt; \n  transmute_at(c(\"species\", \"sex\"), \n               .funs = str_sub, start = 1, end = 3)\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGen\nNA\n\n\nAde\nmal\n\n\nGen\nfem\n\n\nChi\nmal\n\n\nAde\nmal\n\n\nChi\nfem\n\n\n\n\n\n\n\n\n\nacross()関数では、処理を実行する関数（上記の例ではstr_to_upper()関数）の第一引数に.cols引数で指定した変数の値が渡されます。値以外や、第一引数以外に値を渡す必要がある場合などは、次のような書き方で渡される値を明示的に指定します。 )\n\nチルダ無名関数1無名関数2チルダとリストの組み合わせ\n\n\n\n# species及びsexの値は .x としてstr_sub()の第一引数に渡される\npenguins_small |&gt; \n  mutate(across(c(species, sex), ~ str_sub(.x, 1, 2)), .keep = \"none\")\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGe\nNA\n\n\nAd\nma\n\n\nGe\nfe\n\n\nCh\nma\n\n\nAd\nma\n\n\nCh\nfe\n\n\n\n\n\n\n\n\n\n# species及びsexの値は 無名関数の引数xとしてstr_sub()の第一引数に渡される\npenguins_small |&gt; \n  mutate(across(c(species, sex), function(x) str_sub(x, 1, 2)), .keep = \"none\")\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGe\nNA\n\n\nAd\nma\n\n\nGe\nfe\n\n\nCh\nma\n\n\nAd\nma\n\n\nCh\nfe\n\n\n\n\n\n\n\n\n\n# R 4.1.0から利用可能な無名関数の表記も使える\npenguins_small |&gt; \n  mutate(across(c(species, sex), \\(x) str_sub(x, 1, 2)), .keep = \"none\")\n\n\n\n\n\nspecies\nsex\n\n\n\n\nGe\nNA\n\n\nAd\nma\n\n\nGe\nfe\n\n\nCh\nma\n\n\nAd\nma\n\n\nCh\nfe\n\n\n\n\n\n\n\n\n\npenguins_small |&gt; \n  mutate(across(c(species, sex), list(~ str_sub(.x, 1, 2))), .keep = \"none\")\n\n\n\n\n\nspecies_1\nsex_1\n\n\n\n\nGe\nNA\n\n\nAd\nma\n\n\nGe\nfe\n\n\nCh\nma\n\n\nAd\nma\n\n\nCh\nfe\n\n\n\n\n\n\n\n\n\nacross()関数を使った複数列への処理では、通常、加工後の列名は元の列名と一致します。 例えば、ペンギンデータのspeciesごとに数値変数の平均値を求める以下の処理とその結果を見てみましょう。\n\npenguins_small |&gt; \n  group_by(species) |&gt; \n  summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE)))\n\n\n\n\n\nspecies\nbill_length_mm\nbill_depth_mm\n\n\n\n\nAdelie\n37.95\n20.85\n\n\nChinstrap\n48.00\n18.30\n\n\nGentoo\n44.90\n14.00\n\n\n\n\n\n\nこの挙動が問題となることがあります。それは操作対象の変数に複数の関数を適用する場合です。 次の例はペンギンデータのspeciesごとに、数値変数の平均値と標準偏差を求める処理ですが、計算された平均値が元の変数名に格納されるため、標準偏差の計算結果を正しく求めることができなくなっています。\n\npenguins_small |&gt; \n  group_by(species) |&gt; \n  summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE)),\n            across(where(is.numeric), \\(x) sd(x, na.rm = TRUE)))\n\n\n\n\n\nspecies\nbill_length_mm\nbill_depth_mm\n\n\n\n\nAdelie\nNA\nNA\n\n\nChinstrap\nNA\nNA\n\n\nGentoo\nNA\nNA\n\n\n\n\n\n\nこうした場合、across()関数の.names引数が役に立ちます。 以下の例では、平均値を求めるacross()関数と標準偏差を求めるacross()関数それぞれに.names引数を指定しています。注目してほしいのは\"{.col}_\"の部分です。ここにはテンプレートとして元の変数名が使われます。その他、任意の文字列を新たに用意される変数名として利用することができます。\n\npenguins_small |&gt; \n  group_by(species) |&gt; \n  summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE), .names = \"{.col}_mean\"),\n            across(where(is.numeric), \\(x) sd(x, na.rm = TRUE), .names = \"{.col}_sd\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nbill_length_mm_mean\nbill_depth_mm_mean\nbill_length_mm_sd\nbill_depth_mm_sd\nbill_length_mm_mean_sd\nbill_depth_mm_mean_sd\n\n\n\n\nAdelie\n37.95\n20.85\n0.9192388\n0.4949747\nNA\nNA\n\n\nChinstrap\n48.00\n18.30\n6.7882251\n2.4041631\nNA\nNA\n\n\nGentoo\n44.90\n14.00\n0.5656854\n0.4242641\nNA\nNA\n\n\n\n\n\n\n\npenguins_small |&gt; \n  group_by(species) |&gt; \n  summarise(across(where(is.numeric), \n                   list(mean = ~ mean(.x, na.rm = TRUE), \n                        sd = ~ sd(.x, na.rm = TRUE))))\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nbill_length_mm_mean\nbill_length_mm_sd\nbill_depth_mm_mean\nbill_depth_mm_sd\n\n\n\n\nAdelie\n37.95\n0.9192388\n20.85\n0.4949747\n\n\nChinstrap\n48.00\n6.7882251\n18.30\n2.4041631\n\n\nGentoo\n44.90\n0.5656854\n14.00\n0.4242641\n\n\n\n\n\n\n\npenguins_small |&gt; \n  group_by(species) |&gt; \n  summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE), \n                   .names = \"{.col}_mean\"))\n\n\n\n\n\nspecies\nbill_length_mm_mean\nbill_depth_mm_mean\n\n\n\n\nAdelie\n37.95\n20.85\n\n\nChinstrap\n48.00\n18.30\n\n\nGentoo\n44.90\n14.00\n\n\n\n\n\n\n\n\ntidyselect::where\n列の選択を行うselect()関数にも、複数列への処理として、mutate_if()関数やsummarise_at()関数と同様にselect_if()関数等が利用できました。対象の列が一致する条件式を選択する、というもので、次のような記法を実行するのでした。\n\n# 因子型の列を選択\npenguins_small |&gt; \n  select_if(is.factor)\n\n\n\n\n\nspecies\nisland\nsex\n\n\n\n\nGentoo\nBiscoe\nNA\n\n\nAdelie\nTorgersen\nmale\n\n\nGentoo\nBiscoe\nfemale\n\n\nChinstrap\nDream\nmale\n\n\nAdelie\nTorgersen\nmale\n\n\nChinstrap\nDream\nfemale\n\n\n\n\n\n\nところがselect_if()やselect_at()関数はやはりsuperseded扱いとなっています。代わりに、where()関数を使った条件式での列の指定が可能となっています。\n\npenguins_small |&gt; \n  select(where(is.factor))\n\n\n\n\n\nspecies\nisland\nsex\n\n\n\n\nGentoo\nBiscoe\nNA\n\n\nAdelie\nTorgersen\nmale\n\n\nGentoo\nBiscoe\nfemale\n\n\nChinstrap\nDream\nmale\n\n\nAdelie\nTorgersen\nmale\n\n\nChinstrap\nDream\nfemale\n\n\n\n\n\n\n\n\nrename_with\n\n# すべての列を対象に、列名に対してstr_to_upper()関数が適用される\npenguins_small |&gt; \n  rename_with(str_to_upper) |&gt; \n  colnames()\n\n[1] \"SPECIES\"        \"ISLAND\"         \"BILL_LENGTH_MM\" \"BILL_DEPTH_MM\" \n[5] \"SEX\"           \n\n# 列名に対してstr_to_upper()関数が適用されるが、適用範囲を因子型の列だけに制限する\npenguins_small |&gt; \n  rename_with(str_to_upper, where(is.factor)) |&gt; \n  colnames()\n\n[1] \"SPECIES\"        \"ISLAND\"         \"bill_length_mm\" \"bill_depth_mm\" \n[5] \"SEX\""
  },
  {
    "objectID": "sessions/01_dplyr.html#グループ",
    "href": "sessions/01_dplyr.html#グループ",
    "title": "dplyr",
    "section": "グループ",
    "text": "グループ\n先ほど、「種ごとに処理を適用する」例を示しましたが、ここで使われた種、すなわちグループの指定方法に変更があります。\n\npenguins_small |&gt; \n  group_by(species) |&gt; \n  summarise(n = n())\n\n\n\n\n\nspecies\nn\n\n\n\n\nAdelie\n2\n\n\nChinstrap\n2\n\n\nGentoo\n2\n\n\n\n\n\n\n従来は、処理を行う前にgroup_by()関数で明示的にグループ対象の変数を指定する必要がありました。しかし現在は処理を行うmutate()やsummarise()関数の中で.by引数によってグループ対象の変数を指定可能です。\n\npenguins_small |&gt; \n  summarise(n = n(), .by = species)\n\n\n\n\n\nspecies\nn\n\n\n\n\nGentoo\n2\n\n\nAdelie\n2\n\n\nChinstrap\n2\n\n\n\n\n\npenguins_small |&gt; \n  # speciesごとにbill_length_mmの最大値を計算した値が格納される\n  mutate(bill_length_max = max(bill_length_mm, na.rm = TRUE), \n         .by = species) |&gt; \n  # speciesごとにデータを1件ずつ取り出す\n  # bill_lenght_maxの値がspeciesごとに異なることがわかる\n  slice(1, .by = species)\n\n\n\n\n\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nsex\nbill_length_max\n\n\n\n\nGentoo\nBiscoe\n44.5\n14.3\nNA\n45.3\n\n\nAdelie\nTorgersen\n38.6\n21.2\nmale\n38.6\n\n\nChinstrap\nDream\n52.8\n20.0\nmale\n52.8\n\n\n\n\n\npenguins_small |&gt; \n  reframe(n = n(), .by = species)\n\n\n\n\n\nspecies\nn\n\n\n\n\nGentoo\n2\n\n\nAdelie\n2\n\n\nChinstrap\n2\n\n\n\n\n\n\nまた、複数のグループを指定した後の処理でグループを維持し続けるかを.groups引数で選択することが可能です。\n\n# group_by()で与えた最初のグループは解除されるが、以降のグループは維持される\n# グループ化の処理に対して、どのような振る舞いをするかを.groups引数で指定しないと\n# 警告文が出力される\npenguins_small |&gt; \n  group_by(species, island, sex) |&gt; \n  summarise(mean_bl = mean(bill_length_mm, na.rm = TRUE))\n\n`summarise()` has grouped output by 'species', 'island'. You can override using\nthe `.groups` argument.\n\n\n\n\n\n\nspecies\nisland\nsex\nmean_bl\n\n\n\n\nAdelie\nTorgersen\nmale\n37.95\n\n\nChinstrap\nDream\nfemale\n43.20\n\n\nChinstrap\nDream\nmale\n52.80\n\n\nGentoo\nBiscoe\nfemale\n45.30\n\n\nGentoo\nBiscoe\nNA\n44.50\n\n\n\n\n\n\n.groups引数に”drop”を与えた場合、すべてのグループが解除されます。一方、グループを継続するには”keep”を与えます。\n\npenguins_small |&gt; \n  group_by(species, island, sex) |&gt; \n  summarise(mean_bl = mean(bill_length_mm, na.rm = TRUE), \n            .groups = \"drop\")\n\n\n\n\n\nspecies\nisland\nsex\nmean_bl\n\n\n\n\nAdelie\nTorgersen\nmale\n37.95\n\n\nChinstrap\nDream\nfemale\n43.20\n\n\nChinstrap\nDream\nmale\n52.80\n\n\nGentoo\nBiscoe\nfemale\n45.30\n\n\nGentoo\nBiscoe\nNA\n44.50\n\n\n\n\n\npenguins_small |&gt; \n  group_by(species, island, sex) |&gt; \n  summarise(mean_bl = mean(bill_length_mm, na.rm = TRUE), \n            .groups = \"keep\")\n\n\n\n\n\nspecies\nisland\nsex\nmean_bl\n\n\n\n\nAdelie\nTorgersen\nmale\n37.95\n\n\nChinstrap\nDream\nfemale\n43.20\n\n\nChinstrap\nDream\nmale\n52.80\n\n\nGentoo\nBiscoe\nfemale\n45.30\n\n\nGentoo\nBiscoe\nNA\n44.50"
  },
  {
    "objectID": "sessions/01_dplyr.html#データ結合",
    "href": "sessions/01_dplyr.html#データ結合",
    "title": "dplyr",
    "section": "データ結合",
    "text": "データ結合\ndplyrパッケージには次の表に示す通り、柔軟なデータ結合関数が提供されています。\n\n\n\n\n\n\n\n関数名\n説明\n\n\n\n\ninner_join()\nキーとして指定した変数から、二つのデータフレームに共通して存在するレコードを結合して返す\n\n\nleft_join()\nキーとして指定した変数から、左（第一引数）のデータフレームに存在するレコードを結合して返す\n\n\nright_join()\nキーとして指定した変数から、右（第二引数）のデータフレームに存在するレコードを結合して返す\n\n\nfull_join()\nキーとして指定した変数から、二つのデータフレームのいずれかに存在するレコードを結合して返す\n\n\nsemi_join()\n(絞り込み)\n\n\nanti_join()\nキーとして指定した変数から、左（第一引数）のデータフレームに存在しないレコードを結合して返す\n\n\ncross_join()\n二つのデータフレームのすべての組み合わせを結合して返す\n\n\n\n実行は以下のように、対象のデータのほか、キーとなる変数をby引数で指定します。\ninner_join(データ1, データ2, by = \"キーとなる変数\")\nこのby引数の指定方法として、join_by()関数を利用することもできます。この関数により、より柔軟な結合条件の指定が実現します。\n\npenguins_ja &lt;-\n tibble(\n  species = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n  name = c(\"アデリーペンギン\", \"ジェンツーペンギン\", \"ヒゲペンギン\"),\n  redlist = c(\"NT\", \"LC\", NA_character_))\n\n\njoin_by()by引数\n\n\n\npenguins_small |&gt; \n  distinct(species, island) |&gt;\n  left_join(penguins_ja, by = join_by(species))\n\n\n\n\n\nspecies\nisland\nname\nredlist\n\n\n\n\nGentoo\nBiscoe\nジェンツーペンギン\nLC\n\n\nAdelie\nTorgersen\nアデリーペンギン\nNT\n\n\nChinstrap\nDream\nヒゲペンギン\nNA\n\n\n\n\n\n\n\n\n\npenguins_small |&gt; \n  distinct(species, island) |&gt;\n  left_join(penguins_ja, by = c(\"species\"))\n\n\n\n\n\nspecies\nisland\nname\nredlist\n\n\n\n\nGentoo\nBiscoe\nジェンツーペンギン\nLC\n\n\nAdelie\nTorgersen\nアデリーペンギン\nNT\n\n\nChinstrap\nDream\nヒゲペンギン\nNA\n\n\n\n\n\n\n\n\n\n\npenguins_ja2 &lt;-\n tibble(\n  name = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n  jp_name = c(\"アデリーペンギン\", \"ジェンツーペンギン\", \"ヒゲペンギン\"),\n  redlist = c(\"NT\", \"LC\", NA_character_))\n\n\njoin_by()by引数\n\n\n\npenguins_small |&gt; \n  distinct(species, island) |&gt;\n  left_join(penguins_ja2, by = join_by(species == name))\n\n\n\n\n\nspecies\nisland\njp_name\nredlist\n\n\n\n\nGentoo\nBiscoe\nジェンツーペンギン\nLC\n\n\nAdelie\nTorgersen\nアデリーペンギン\nNT\n\n\nChinstrap\nDream\nヒゲペンギン\nNA\n\n\n\n\n\n\n\n\n\npenguins_small |&gt; \n  distinct(species, island) |&gt;\n  left_join(penguins_ja2, by = c(\"species\" = \"name\"))\n\n\n\n\n\nspecies\nisland\njp_name\nredlist\n\n\n\n\nGentoo\nBiscoe\nジェンツーペンギン\nLC\n\n\nAdelie\nTorgersen\nアデリーペンギン\nNT\n\n\nChinstrap\nDream\nヒゲペンギン\nNA\n\n\n\n\n\n\n\n\n\n\npenguins_name &lt;-\n tibble(\n  name = c(\"adeliae\", \"Gentoo\", \"antarctica\"),\n  redlist = c(\"NT\", \"LC\", NA_character_))\n\nキー変数の項目が一致しないものがあるとエラーを発生させます。\n\npenguins_small |&gt; \n  distinct(species, island) |&gt;\n  left_join(penguins_name, by = join_by(species == name), unmatched = \"error\")\n\nError in `left_join()`:\n! Each row of `y` must be matched by `x`.\nℹ Row 1 of `y` was not matched.\n\n\nキー変数の項目が一致しないものがあると、そのレコードを除外します。これはデフォルトの挙動です。\n\npenguins_small |&gt; \n  distinct(species, island) |&gt;\n  left_join(penguins_name, by = join_by(species == name), unmatched = \"drop\")\n\n\n\n\n\nspecies\nisland\nredlist\n\n\n\n\nGentoo\nBiscoe\nLC\n\n\nAdelie\nTorgersen\nNA\n\n\nChinstrap\nDream\nNA\n\n\n\n\n\n\nもう一つのオプション\n\ndf_pgid &lt;-\n  tibble(id = seq.int(4),\n       species = c(\"Adelie\", \"Chinstrap\", \"Gentoo\", \"Chinstrap\"))\n       \ndf_pgid\n\n\n\n\n\nid\nspecies\n\n\n\n\n1\nAdelie\n\n\n2\nChinstrap\n\n\n3\nGentoo\n\n\n4\nChinstrap\n\n\n\n\n\ndf_pgname &lt;-\ntibble(\n      species = c(\"Adelie\", \"Chinstrap\", \"Chinstrap\"),\n      name = c(\"アデリーペンギン\", \"ヒゲペンギン\", \"ナンキョクペンギン\"))\n\ndf_pgname\n\n\n\n\n\nspecies\nname\n\n\n\n\nAdelie\nアデリーペンギン\n\n\nChinstrap\nヒゲペンギン\n\n\nChinstrap\nナンキョクペンギン\n\n\n\n\n\n\n\n# multiple = \"all\"の状態\ndf_pgid |&gt; \n  left_join(\n    df_pgname,\n    by = join_by(species))\n\nWarning in left_join(df_pgid, df_pgname, by = join_by(species)): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 2 of `x` matches multiple rows in `y`.\nℹ Row 2 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nid\nspecies\nname\n\n\n\n\n1\nAdelie\nアデリーペンギン\n\n\n2\nChinstrap\nヒゲペンギン\n\n\n2\nChinstrap\nナンキョクペンギン\n\n\n3\nGentoo\nNA\n\n\n4\nChinstrap\nヒゲペンギン\n\n\n4\nChinstrap\nナンキョクペンギン\n\n\n\n\n\n\n結合するデータの件数が多い場合、問題がどこかに混ざる危険があります。 新しい*_join()関数では、このような問題を回避するために、結合先のレコードが複数ある場合、デフォルトではエラーを返却します。データや目的に応じて、ユーザー自身が複数の値への対処法を決定することができます。\n\n# 結合先が複数ある状態で、最初のレコードのみを結合する\n# multiple = \"last\" にすると最後のレコードのみを結合する\ndf_pgid |&gt; \n  left_join(\n    df_pgname,\n    by = join_by(species),\n    multiple = \"first\")\n\n\n\n\n\nid\nspecies\nname\n\n\n\n\n1\nAdelie\nアデリーペンギン\n\n\n2\nChinstrap\nヒゲペンギン\n\n\n3\nGentoo\nNA\n\n\n4\nChinstrap\nヒゲペンギン\n\n\n\n\n\n\n\ndf_pgid |&gt; \n  left_join(\n    df_pgname,\n    by = join_by(species),\n    multiple = \"all\",\n    relationship = \"many-to-many\")\n\n\n\n\n\nid\nspecies\nname\n\n\n\n\n1\nAdelie\nアデリーペンギン\n\n\n2\nChinstrap\nヒゲペンギン\n\n\n2\nChinstrap\nナンキョクペンギン\n\n\n3\nGentoo\nNA\n\n\n4\nChinstrap\nヒゲペンギン\n\n\n4\nChinstrap\nナンキョクペンギン\n\n\n\n\n\n\n非等価結合、ローリング結合等はスキップ…\n\npenguins_name &lt;-\n  tibble(\n    name = c(\"Adelie\", \"Gentoo\", \"Chinstrap\"),\n    preview_n = c(160, 121, 60),\n    redlist = c(\"NT\", \"LC\", NA_character_))\n\n# Adelieはn &gt;= preview_nの条件に合わないので結合から除外される\npenguins_small |&gt; \n  count(species) |&gt; \n  left_join(penguins_name, by = join_by(species == name, n &gt;= preview_n))\n\n\n\n\n\nspecies\nn\npreview_n\nredlist\n\n\n\n\nAdelie\n2\nNA\nNA\n\n\nChinstrap\n2\nNA\nNA\n\n\nGentoo\n2\nNA\nNA"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "次の一歩を踏み出すためのtidyverse入門",
    "section": "",
    "text": "tidyverseはR言語でのデータ分析を行う際に便利なパッケージの集まりです。 統一された設計思想のもとに、ファイルの読み書き（readr）からデータ操作（dplyr、tidyr）、可視化（ggplot2）などのパッケージを提供しています。2016年の登場から度重なるアップデートを経て、現在の最新バージョンは2.0.0と成熟期を迎えている状態です。 国内外でtidyverseや関係するパッケージの解説は豊富に存在します。一方でRでの関数型プログラミングを補助するpurrrパッケージなど、他と比べて焦点を当てられる機会が少ないパッケージ・関数も見受けられます。この要因として、tidyverseの更新速度に追いつけず、新しい機能について十分に身につけることができないことがあると私は考えています。\nこの資料では、tidyverseのさらなる活用を目指す人を対象に、これらの使い方を解説するとともに、より効率的に作業を進めるためのノウハウを伝授することを目指しています。具体的には、tidyverseのコアパッケージでるdplyr、tidyr、purrrを中心に扱います。また、それ以外のtidyverseパッケージ群を組み合わせた、発展的な話題を紹介します。\ntidyverseとは何か？そこから知りたい人は概論をご覧ください。なお、紹介するパッケージの基本的な情報については既存の資料を参考にしてください。"
  },
  {
    "objectID": "index.html#tidyverseパッケージの読み込み",
    "href": "index.html#tidyverseパッケージの読み込み",
    "title": "次の一歩を踏み出すためのtidyverse入門",
    "section": "tidyverseパッケージの読み込み",
    "text": "tidyverseパッケージの読み込み\n資料全体を通してtidyverseパッケージを利用します。次のコマンドでtidyverseに含まれる各パッケージを利用可能な状態にしておきましょう。なおパッケージのインストールはinstall.packages(\"tidyverse\")で行われます1。\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\ntidyverseパッケージの最新版は、2023年8月27日現在、v2.0.0です。この資料でも最新版のv2.0.0を利用します。\n\n主な対象者\n\ndplyrやggplot2、tidyrについての基礎知識がある\ntidyverseに含まれるパッケージの関数の知識を更新したい … dplyr、tidyr、purrrの情報をアップデート\nデータフレームだけでなく、リストの操作も快適に行えるようになりたい… purrrについての理解を深める\n繰り返しの処理を書きがち、コードを簡潔に記述したい… purrrで効率的な処理！\n関数を書くことがない、あるいは少ない… rlangを使った関数が書けるように（目標）"
  },
  {
    "objectID": "index.html#目次",
    "href": "index.html#目次",
    "title": "次の一歩を踏み出すためのtidyverse入門",
    "section": "目次",
    "text": "目次\n\ntidyverse概論\ndplyr\ntidyr\npurrr\n発展"
  },
  {
    "objectID": "index.html#謝辞",
    "href": "index.html#謝辞",
    "title": "次の一歩を踏み出すためのtidyverse入門",
    "section": "謝辞",
    "text": "謝辞\nこのプロジェクトを含め、私のOSSに携わる活動を支援してくださっているGitHubスポンサーの方々に、感謝申し上げます。 活動を支援するためにGitHubスポンサーに加わっていただける方はこちらのリンクから登録をお願います。"
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "次の一歩を踏み出すためのtidyverse入門",
    "section": "脚注",
    "text": "脚注\n\n\nGitHubリポジトリからこの資料をクローンまたはダウンロードした方はrenvパッケージを使ってパッケージを復元することが可能です。↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "このページは2023年8月27日に開催される統計数理研究所 統計思考院オンラインワークショップ「探索的ビッグデータ解析と再現可能研究」での発表の一つ、「次の一歩を踏み出すためのtidyverse入門」（発表者： 瓜生真也 の資料置き場です。\nウェブサイトはQuartoを使って構築されています。 このページの内容を記載した.qmdファイルは GitHub上のリポジトリに保存されています。 内容についてご意見、改善の提案がある方はissuesに投稿をお願いします。"
  },
  {
    "objectID": "about.html#実行環境",
    "href": "about.html#実行環境",
    "title": "About",
    "section": "実行環境",
    "text": "実行環境\n\nR 4.3.1\nmacOS Ventura 13.4.1\n\n\nrenvを使った環境の復元\n\nrenv::install()"
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "ライセンス",
    "section": "",
    "text": "資料のうち、プログラム部分はMITライセンスに従い利用できます。プログラム部分以外（文章や画像）はクリエイティブ・コモンズ 表示 - 非営利 - 改変禁止 4.0 国際 (CC BY-NC-ND 4.0)のもと再利用が可能です。"
  },
  {
    "objectID": "license.html#mit-license",
    "href": "license.html#mit-license",
    "title": "ライセンス",
    "section": "MIT License",
    "text": "MIT License\nCopyright (c) 2023 Shinya Uryu\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "sessions/00_tidyverse.html",
    "href": "sessions/00_tidyverse.html",
    "title": "tidyverse概論",
    "section": "",
    "text": "ここでは、tidyverseはR上でデータサイエンスを円滑に行うためのパッケージ群、またそのパッケージのことを指します。次の図で示すように、tidyverseでは多種多様なデータ形式に対応したファイルの読み込みから、データ整形、可視化までを首尾一貫して行えるパッケージを提供されています。\n\n\n\ntidyverseに含まれるパッケージとその役割\n\n\nこれらのパッケージの開発者はPosit社のメンバーが中心となっており、統一的な設計思想に基づいて開発が行われています。そのため、各パッケージ間での利用方法の差異が少なく、連携が容易な点もtidyverseを使う一つの利点となります。\ntidyverseパッケージは次のコマンドを実行することでインストールされます。たくさんのパッケージをインストールするため、少し時間がかかるかもしれません。ですが、一度インストールしておくと、tidyverseに含まれるパッケージを個別にインストールする手間がなくなります。\n\ninstall.packages(\"tidyverse\")\n\nインストールは済みましたか？\nそれでは、tidyverseパッケージ（そしてそれに含まれる各種パッケージ）を 利用可能にしましょう。\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nlibrary(tidyverse)を実行すると、コンソールにメッセージが表示されます。 メッセージは2つの内容を含んでいて、一つは利用可能となったパッケージについて、もう一つは関数名の衝突についての情報です。それぞれ詳しく見ていきましょう。\n最初の出力では、tidyverseパッケージ本体のバージョン、またtidyverseによって読み込まれたtidyverseのコアパッケージとそのバージョンを出力しています。この資料を作成している段階では、tidyverseコアパッケージには次のものが含まれます（括弧内はバージョン）。\n\ndplyr (1.1.2)\nreadr (2.1.4)\nforcats (1.0.0)\nstringr (1.5.0)\nggplot (3.4.3)\ntibble (3.2.1)\nlubridate (1.9.2)\ntidyr (1.3.0)\npurrr (1.0.2)\n\nConflictsと表示された2つめの出力は、tidyverseパッケージ群を読み込むことで発生した、関数名の競合状態を示すものです。関数名が競合するとはどういうことでしょう。\nRにはたくさんのパッケージがあり、各パッケージには関数が存在します。そのため、AとB、二つのパッケージで共通の名前をもつ関数（example()関数とします）が利用可能な状態となることがしばしばあります。この場合、Aパッケージのexample()関数を使いたいのに、Bパッケージのexample()関数が実行されてしまう可能性があります。\ntidyverse群の中で、dplyrパッケージのfilter()関数およびlag()関数は、Rの標準パッケージのstatsの同一名の関数と競合します。同じ名前の関数が複数のパッケージで利用できる状態では、後から読み込まれたパッケージが優先されます。そのため、この出力はdplyrパッケージのfilter()関数とlag()関数が利用されることを示すものとなっています。\n関数の衝突問題を解決するためのconflictedパッケージもtidyverseに含まれています。パッケージ間での関数の優先順位を変更するのに役立ちますので、興味のある方はウェブページをご覧ください。"
  },
  {
    "objectID": "sessions/02_tidyr.html",
    "href": "sessions/02_tidyr.html",
    "title": "tidyr",
    "section": "",
    "text": "tidyrはデータフレームの形状を自由自在に変更するのに役立つパッケージです。messy、散らかったデータをtidy、整然なデータに変換することがtidyrの目的です。tidyデータ形式の詳細はHadley(2014)やこちらが参考にしてください。このほか、データの形状を変更するための関数を提供します。"
  },
  {
    "objectID": "sessions/02_tidyr.html#tidyr速習",
    "href": "sessions/02_tidyr.html#tidyr速習",
    "title": "tidyr",
    "section": "",
    "text": "tidyrはデータフレームの形状を自由自在に変更するのに役立つパッケージです。messy、散らかったデータをtidy、整然なデータに変換することがtidyrの目的です。tidyデータ形式の詳細はHadley(2014)やこちらが参考にしてください。このほか、データの形状を変更するための関数を提供します。"
  },
  {
    "objectID": "sessions/02_tidyr.html#横長データと縦長データ",
    "href": "sessions/02_tidyr.html#横長データと縦長データ",
    "title": "tidyr",
    "section": "横長データと縦長データ",
    "text": "横長データと縦長データ\nデータの形状を表現する言葉として、しばしば「横長（あるいは横持ち）」「縦長（あるいは縦持ち）」が使われます。\n\n横長… 変数が列、観測値が行に記録される\n縦長… 変数が行、観測値が列に記録される\n\n具体例を見てみましょう。\n\n# 2020年国勢調査での四国4県の男女別人口\ndf_wide &lt;- \n  tibble(\n    area = c(\"徳島県\", \"香川県\", \"愛媛県\", \"高知県\"), \n    男 = c(343265, 459197, 633062, 326531), \n    女 = c(376294, 491047, 701779, 364996))\n\ndf_wide\n\n\n\n\n\narea\n男\n女\n\n\n\n\n徳島県\n343265\n376294\n\n\n香川県\n459197\n491047\n\n\n愛媛県\n633062\n701779\n\n\n高知県\n326531\n364996\n\n\n\n\n\n\n本来、性別として一つの変数で扱えるはずのデータが、男と女という2つの変数に分かれてしいます。こうした横長のデータは、表計算ソフトでの入力には便利ですが、データ分析には不便です。データ分析では、男あるいは女として性別を扱うのではなく、性別の項目として男女の違いを扱うことが多いからです。\nこのデータを縦長形式で表現すると次のようになります。\n\ndf_long &lt;- \n  tibble(\n  area = rep(c(\"徳島県\", \"香川県\", \"愛媛県\", \"高知県\"), each = 2),\n  gender = rep(c(\"男\", \"女\"), times = 4),\n  value = c(343265, 376294, 459197, 491047, 633062, 701779,\n            326531, 364996))\ndf_long\n\n\n\n\n\narea\ngender\nvalue\n\n\n\n\n徳島県\n男\n343265\n\n\n徳島県\n女\n376294\n\n\n香川県\n男\n459197\n\n\n香川県\n女\n491047\n\n\n愛媛県\n男\n633062\n\n\n愛媛県\n女\n701779\n\n\n高知県\n男\n326531\n\n\n高知県\n女\n364996\n\n\n\n\n\n\n横長データと比べて、縦長データは冗長なようにも見えますが、Rの多くの関数は縦長のデータを好みます。例えばggplot2で性別ごとの人口を棒グラフで表示するには、縦長データを直接利用可能です。\n\nggplot(df_long) +\n    aes(area, value, fill = gender, group = gender) +\n    geom_bar(stat = \"identity\", position = \"dodge\") +\n    scale_fill_manual(values = list(`男` = \"#001964\", `女` = \"#AF1900\")) +\n    scale_y_continuous(labels = zipangu::label_kansuji()) +\n    labs(title = \"2020年国勢調査での四国4県の男女別人口\",\n         x = \"都道府県\", y = \"人口\")\n\n\n\n\ntidyrではこのような縦長・横長のデータ形式の変換を実現する関数が用意されています。縦長データを横長データに変換するにはpivot_wider()を、横長データを縦長データに変換するにはpivot_longer()を利用します。\n\n# 横長から縦長へ\ndf_wide |&gt; \n  pivot_longer(cols = 2:3, names_to = \"gender\", values_to = \"value\")\n\n\n\n\n\narea\ngender\nvalue\n\n\n\n\n徳島県\n男\n343265\n\n\n徳島県\n女\n376294\n\n\n香川県\n男\n459197\n\n\n香川県\n女\n491047\n\n\n愛媛県\n男\n633062\n\n\n愛媛県\n女\n701779\n\n\n高知県\n男\n326531\n\n\n高知県\n女\n364996\n\n\n\n\n\n\n\n# 縦長から横長へ\ndf_long |&gt; \n  pivot_wider(names_from = gender, values_from = value)\n\n\n\n\n\narea\n男\n女\n\n\n\n\n徳島県\n343265\n376294\n\n\n香川県\n459197\n491047\n\n\n愛媛県\n633062\n701779\n\n\n高知県\n326531\n364996\n\n\n\n\n\n\npivot_wider()関数では、対象のデータフレーム中の値と項目を格納する変数名とその値を\n既存の変数は引用符をつけずに指定します。一方で、元のデータフレームに存在しない列名を追加する"
  },
  {
    "objectID": "sessions/02_tidyr.html#separate_wider_-separate_longer_",
    "href": "sessions/02_tidyr.html#separate_wider_-separate_longer_",
    "title": "tidyr",
    "section": "separate_wider_* / separate_longer_*",
    "text": "separate_wider_* / separate_longer_*\n\ntibble(zipcode = c(\"100-0004\", \n                   \"700-0027\")) |&gt; \n  separate_wider_delim(cols = zipcode, \n                       delim = \"-\", \n                       names = c(\"code1\", \"code2\"))\n\n\n\n\n\ncode1\ncode2\n\n\n\n\n100\n0004\n\n\n700\n0027"
  },
  {
    "objectID": "sessions/02_tidyr.html#nest-unnest_wider-unnest_longer",
    "href": "sessions/02_tidyr.html#nest-unnest_wider-unnest_longer",
    "title": "tidyr",
    "section": "nest / unnest_wider / unnest_longer",
    "text": "nest / unnest_wider / unnest_longer\n\nlibrary(jpmesh)\njpmesh::administration_mesh(36, to_mesh_size = 80)\n\n\n\n\n\nmeshcode\ngeometry\n\n\n\n\n5034\nPOLYGON ((134 33.33333, 135…\n\n\n5134\nPOLYGON ((134 34, 135 34, 1…\n\n\n5133\nPOLYGON ((133 34, 134 34, 1…\n\n\n5033\nPOLYGON ((133 33.33333, 134…\n\n\n\n\n\ntibble(\n  prefcode = str_pad(seq.int(36, 37), width = 2, pad = \"0\")) %&gt;%\n  mutate(meshcode = map(., \\(prefcode) jpmesh::administration_mesh(prefcode, to_mesh_size = 80))) |&gt; \n  unnest(cols = meshcode)\n\n\n\n\n\nprefcode\nmeshcode\ngeometry\n\n\n\n\n36\n5034\nPOLYGON ((134 33.33333, 135…\n\n\n36\n5134\nPOLYGON ((134 34, 135 34, 1…\n\n\n36\n5133\nPOLYGON ((133 34, 134 34, 1…\n\n\n36\n5033\nPOLYGON ((133 33.33333, 134…\n\n\n37\n5034\nPOLYGON ((134 33.33333, 135…\n\n\n37\n5134\nPOLYGON ((134 34, 135 34, 1…\n\n\n37\n5133\nPOLYGON ((133 34, 134 34, 1…\n\n\n37\n5033\nPOLYGON ((133 33.33333, 134…\n\n\n\n\n\n\n\nzipangu::separate_address(\"東京都千代田区大手町一丁目\")\n\n$prefecture\n[1] \"東京都\"\n\n$city\n[1] \"千代田区\"\n\n$street\n[1] \"大手町一丁目\"\n\ndf_address &lt;- \n  tibble(address = c(\"東京都千代田区大手町一丁目\", \n                   \"岡山県岡山市北区清心町16-13\")) %&gt;%\n  mutate(address_components = purrr::pmap(., ~ zipangu::separate_address(..1)))  \n\ndf_address |&gt; \n  unnest_wider(col = address_components)\n\n\n\n\n\naddress\nprefecture\ncity\nstreet\n\n\n\n\n東京都千代田区大手町一丁目\n東京都\n千代田区\n大手町一丁目\n\n\n岡山県岡山市北区清心町16-13\n岡山県\n岡山市北区\n清心町16-13\n\n\n\n\n\ndf_address |&gt; \n  unnest_longer(col = address_components)\n\n\n\n\n\n\n\n\n\n\naddress\naddress_components\naddress_components_id\n\n\n\n\n東京都千代田区大手町一丁目\n東京都\nprefecture\n\n\n東京都千代田区大手町一丁目\n千代田区\ncity\n\n\n東京都千代田区大手町一丁目\n大手町一丁目\nstreet\n\n\n岡山県岡山市北区清心町16-13\n岡山県\nprefecture\n\n\n岡山県岡山市北区清心町16-13\n岡山市北区\ncity\n\n\n岡山県岡山市北区清心町16-13\n清心町16-13\nstreet"
  },
  {
    "objectID": "sessions/02_tidyr.html#extract",
    "href": "sessions/02_tidyr.html#extract",
    "title": "tidyr",
    "section": "extract",
    "text": "extract\n\ntibble(month = c(\"令和4年12月\", \"令和4年11月\", \n\"令和4年10月\", \"令和4年9月\", \"令和4年8月\", \"令和4年7月\"\n)) |&gt; \nextract(month,\n                   c(\"year\", \"month\"),\n                   \"(令和.+年|平成.+年)([0-9]{1,2}月)\")\n\n\n\n\n\nyear\nmonth\n\n\n\n\n令和4年\n12月\n\n\n令和4年\n11月\n\n\n令和4年\n10月\n\n\n令和4年\n9月\n\n\n令和4年\n8月\n\n\n令和4年\n7月"
  },
  {
    "objectID": "sessions/02_tidyr.html#pack-unpack",
    "href": "sessions/02_tidyr.html#pack-unpack",
    "title": "tidyr",
    "section": "pack / unpack",
    "text": "pack / unpack\njmastats\n\nlibrary(jmastats)\ndf_pack &lt;- \n  jma_collect(item = \"monthly\", block_no = \"47895\", year = 2022, month = 1, pack = TRUE)\n\nData from: https://www.data.jma.go.jp/obd/stats/etrn/view/monthly_s1.php?prec_no=71&block_no=47895&year=2022&month=1&day=&view=Treated as missing: lines 1, 2, 12 at temperature_min(℃)\nTreated as missing: lines 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 at solar_irradiance_average(MJ/m^2)\nTreated as missing: lines 1, 3, 4, 5, 6, 7, 8, 9, 10, 11 at snow_fall(cm)\nTreated as missing: lines 1, 3, 4, 5, 6, 7, 8, 9, 10, 11 at snow_max_fall_day(cm)\nTreated as missing: lines 1, 3, 4, 5, 6, 7, 8, 9, 10, 11 at snow_depth(cm)\nTreated as missing: lines 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 at cloud_covering_mean\nTreated as missing: lines 4, 6, 8, 10 at condition_snow_days\nTreated as missing: lines 4, 6, 8, 10 at condition_fog_days\nTreated as missing: lines 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12 at condition_thunder_days\n\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  .default = col_double(),\n  wind_max_speed_direction = col_character(),\n  wind_max_instantaneous_direction = col_character(),\n  `solar_irradiance_average(MJ/m^2)` = col_logical(),\n  cloud_covering_mean = col_logical()\n)\nℹ Use `spec()` for the full column specifications.\n\ndf_unpack &lt;- \n  jma_collect(item = \"monthly\", block_no = \"47895\", year = 2022, month = 1, pack = FALSE)\n\n\nglimpse(df_pack)\n\nRows: 12\nColumns: 11\n$ month            &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n$ atmosphere       &lt;tibble[,2]&gt; &lt;tbl_df[12 x 2]&gt;\n$ precipitation    &lt;tibble[,4]&gt; &lt;tbl_df[12 x 4]&gt;\n$ temperature      &lt;tibble[,5]&gt; &lt;tbl_df[12 x 5]&gt;\n$ humidity         &lt;tibble[,2]&gt; &lt;tbl_df[12 x 2]&gt;\n$ wind             &lt;tibble[,5]&gt; &lt;tbl_df[12 x 5]&gt;\n$ daylight         &lt;tibble[,1]&gt; &lt;tbl_df[12 x 1]&gt;\n$ snow             &lt;tibble[,3]&gt; &lt;tbl_df[12 x 3]&gt;\n$ solar_irradiance &lt;tibble[,1]&gt; &lt;tbl_df[12 x 1]&gt;\n$ cloud_covering   &lt;tibble[,1]&gt; &lt;tbl_df[12 x 1]&gt;\n$ condition        &lt;tibble[,3]&gt; &lt;tbl_df[12 x 3]&gt;\n\n\n\nglimpse(df_unpack)\n\nRows: 12\nColumns: 28\n$ month                               &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,…\n$ `atmosphere_land(hPa)`              &lt;dbl&gt; 1019.5, 1020.4, 1016.1, 1015.8, 10…\n$ `atmosphere_surface(hPa)`           &lt;dbl&gt; 1020.3, 1021.2, 1016.9, 1016.6, 10…\n$ `precipitation_sum(mm)`             &lt;dbl&gt; 22.5, 38.5, 86.0, 94.0, 155.0, 89.…\n$ `precipitation_max_per_day(mm)`     &lt;dbl&gt; 14.0, 20.0, 42.0, 30.0, 56.5, 24.5…\n$ `precipitation_max_1hour(mm)`       &lt;dbl&gt; 4.5, 3.0, 13.5, 17.0, 15.0, 15.0, …\n$ `precipitation_max_10minutes(mm)`   &lt;dbl&gt; 2.0, 1.0, 3.5, 5.0, 4.0, 11.0, 6.5…\n$ `temperature_average(℃)`            &lt;dbl&gt; 6.0, 5.5, 11.5, 16.1, 19.6, 23.7, …\n$ `temperature_average_max(℃)`        &lt;dbl&gt; 9.7, 9.5, 15.9, 20.6, 24.0, 27.7, …\n$ `temperature_average_min(℃)`        &lt;dbl&gt; 2.7, 1.9, 7.4, 12.1, 15.4, 20.2, 2…\n$ `temperature_max(℃)`                &lt;dbl&gt; 13.6, 14.6, 21.4, 27.0, 30.2, 34.7…\n$ `temperature_min(℃)`                &lt;dbl&gt; -0.5, -1.2, 2.5, 5.8, 10.0, 15.5, …\n$ `humidity_average(%)`               &lt;dbl&gt; 61, 59, 66, 69, 67, 77, 79, 77, 77…\n$ `humidity_min(%)`                   &lt;dbl&gt; 34, 25, 18, 9, 19, 40, 42, 43, 31,…\n$ `wind_average_speed(m/s)`           &lt;dbl&gt; 3.3, 3.4, 2.9, 2.9, 2.8, 2.7, 3.2,…\n$ `wind_max_speed(m/s)`               &lt;dbl&gt; 8.9, 10.2, 12.2, 9.0, 8.7, 12.5, 8…\n$ wind_max_speed_direction            &lt;chr&gt; \"北西\", \"西北西\", \"南南東\", \"南南…\n$ `wind_max_instantaneous_speed(m/s)` &lt;dbl&gt; 15.6, 19.1, 20.5, 16.1, 15.0, 21.0…\n$ wind_max_instantaneous_direction    &lt;chr&gt; \"北西\", \"西\", \"南南東\", \"西北西\", …\n$ `daylight_(h)`                      &lt;dbl&gt; 165.2, 190.2, 193.8, 210.3, 208.4,…\n$ `solar_irradiance_average(MJ/m^2)`  &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ `snow_fall(cm)`                     &lt;dbl&gt; 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11\n$ `snow_max_fall_day(cm)`             &lt;dbl&gt; 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11\n$ `snow_depth(cm)`                    &lt;dbl&gt; 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10\n$ cloud_covering_mean                 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ condition_snow_days                 &lt;dbl&gt; 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5\n$ condition_fog_days                  &lt;dbl&gt; 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0\n$ condition_thunder_days              &lt;dbl&gt; 0, 0, 0, 2, 0, 4, 7, 17, 8, 3, 1, 0\n\n\n\ndf_pack |&gt; \n  select(month, precipitation) |&gt; \n  unnest(cols = precipitation)\n\n\n\n\n\nmonth\nsum(mm)\nmax_per_day(mm)\nmax_1hour(mm)\nmax_10minutes(mm)\n\n\n\n\n1\n22.5\n14.0\n4.5\n2.0\n\n\n2\n38.5\n20.0\n3.0\n1.0\n\n\n3\n86.0\n42.0\n13.5\n3.5\n\n\n4\n94.0\n30.0\n17.0\n5.0\n\n\n5\n155.0\n56.5\n15.0\n4.0\n\n\n6\n89.5\n24.5\n15.0\n11.0\n\n\n7\n124.0\n43.5\n16.0\n6.5\n\n\n8\n62.5\n14.5\n14.5\n10.0\n\n\n9\n283.0\n117.5\n48.0\n19.5\n\n\n10\n80.5\n24.5\n11.5\n5.5\n\n\n11\n82.0\n23.5\n6.0\n3.0\n\n\n12\n33.0\n9.5\n3.5\n1.5\n\n\n\n\n\n\n\ndf_unpack |&gt; \n  select(month, starts_with(\"precipitation\"))\n\n\n\n\n\n\n\n\n\n\n\n\nmonth\nprecipitation_sum(mm)\nprecipitation_max_per_day(mm)\nprecipitation_max_1hour(mm)\nprecipitation_max_10minutes(mm)\n\n\n\n\n1\n22.5\n14.0\n4.5\n2.0\n\n\n2\n38.5\n20.0\n3.0\n1.0\n\n\n3\n86.0\n42.0\n13.5\n3.5\n\n\n4\n94.0\n30.0\n17.0\n5.0\n\n\n5\n155.0\n56.5\n15.0\n4.0\n\n\n6\n89.5\n24.5\n15.0\n11.0\n\n\n7\n124.0\n43.5\n16.0\n6.5\n\n\n8\n62.5\n14.5\n14.5\n10.0\n\n\n9\n283.0\n117.5\n48.0\n19.5\n\n\n10\n80.5\n24.5\n11.5\n5.5\n\n\n11\n82.0\n23.5\n6.0\n3.0\n\n\n12\n33.0\n9.5\n3.5\n1.5"
  },
  {
    "objectID": "sessions/04_advanced.html",
    "href": "sessions/04_advanced.html",
    "title": "Advanced",
    "section": "",
    "text": "install.packages('jmastats', repos = c('https://uribo.r-universe.dev', 'https://cloud.r-project.org'))\n\n\nlibrary(jmastats)\n\n\ndata(stations, package = \"jmastats\")\n\njmastatsパッケージは日本の気象庁が提供する気象データをRから利用可能にするパッケージです。このパッケージを用いて、四国4県を代表する気象観測所4地点（徳島, 高松, 松山, 高知)での2023年7月の気象データを取得する場面を考えます。\njmastatsパッケージでは、jma_collect()関数を使って目的の気象データの取得を行います。その際、データの種類（ここでは2023年7月の日ごとの観測値が知りたいので”daily”を指定します）、取得対象の年月日、取得対象の気象観測所が位置するコード（block_no）を指定します。\n「徳島」のblock_noは”47895”なので、次のようにすると2023年7月の日ごとの気象データが取得されます。\n\njma_collect(item = \"daily\", block_no = \"47895\", year = 2023, month = 7)\n\nでは、対象の気象観測所を増やしてデータ取得を行いましょう。 まずは4地点の気象観測所のblock_noを調べる必要があります。 この処理は次のコードで実行します。\n\ndf_targets_st &lt;- \n  # jmastatsパッケージに含まれる気象観測所のデータ\n  stations |&gt; \n  # 1. 観測所の名前が同じで四国以外に位置する観測所を除外するため、\n  #    都道府県コードによる絞り込みを行う\n  filter(pref_code %in% as.character(seq.int(36, 39))) |&gt; \n  # 2. 四国県内で目的の気象観測所の名称で絞り込む\n  filter(station_name %in% c(\"徳島\", \"高松\", \"松山\", \"高知\")) |&gt; \n  # 3. 同一の気象観測所が複数行に分かれて記録されていることがあるのでユニークにする\n  distinct(block_no, station_name, pref_code)\n\n\ndf_targets_st\n\n\n\n\n\nblock_no\nstation_name\npref_code\n\n\n\n\n47895\n徳島\n36\n\n\n47891\n高松\n37\n\n\n47887\n松山\n38\n\n\n47893\n高知\n39\n\n\n\n\n\n\n対象の気象観測所のblock_noがわかったので、jma_collect()関数を使ってデータを取得しましょう。 先ほど示したコードのblock_no引数を変更するだけです。\n\njma_collect(item = \"daily\", block_no = \"47895\", year = 2023, month = 7)\njma_collect(item = \"daily\", block_no = \"47891\", year = 2023, month = 7)\njma_collect(item = \"daily\", block_no = \"47887\", year = 2023, month = 7)\njma_collect(item = \"daily\", block_no = \"47893\", year = 2023, month = 7)\n\nちょっと待ってください！ あなたが書こうと思いついたコードはどんなものですか？ もし、上に示したようにjma_collect()関数の引数block_no部分だけを変えることを考えていたのであれば、purrrパッケージを使ったコードに置き換えることが可能です。purrrパッケージを使うことで、jma_collect()関数の指定は1回で済み、コードも簡略化できます。\n\ndf_targets_st |&gt; \n  pluck(\"block_no\") |&gt; \n  map(\n    \\(x) jma_collect(item = \"daily\", block_no = x, year = 2023, month = 7)\n  )\n\n同じ関数を繰り返し記載したコードでは、どの引数が同じで、どの引数が違うのか注意を払う必要が生じます（例えば2023年7月の値を参照しているなかで、ある箇所だけが2020年8月と書いてしまうことがあるかもしれません）。map()関数ではそのような繰り返しの処理の引数の違いを心配することがなく、繰り返しの中での変更点だけに注意することができます。\n次に、取得した気象データを一つのデータフレームに格納することを考えましょう。その際、各データがどの気象観測所のものなのかわかるよう、station_name変数に気象観測所の名称を記録しておきます。この処理を回りくどく書くと次のようになります。\n\nbind_rows(\n  jma_collect(item = \"daily\", block_no = \"47895\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"徳島\", .before = 1),\n  jma_collect(item = \"daily\", block_no = \"47891\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"高松\", .before = 1),\n  jma_collect(item = \"daily\", block_no = \"47887\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"松山\", .before = 1),\n  jma_collect(item = \"daily\", block_no = \"47893\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"高知\", .before = 1))\n\n列を追加するmutate()関数も対象の気象観測所の数に応じて追加することになり、書かなければいけないコード量が増えてしまいました。\nmap()関数の返り値はリスト形式ですが、リストの中身がデータフレームである場合、それらを一つのデータフレームにまとめる関数list_rbind()が用意されています。また、便利なのがset_names()関数とlist_rbind()関数のnames_to引数を組み合わせることで、各データフレームに任意の列名と値を追加可能です。\n\ndf_targets_st |&gt; \n  pluck(\"block_no\") |&gt; \n  set_names(df_targets_st |&gt; \n              pluck(\"station_name\")) |&gt; \n  map(\n    \\(x) jma_collect(item = \"daily\", block_no = x, year = 2023, month = 7)\n  ) |&gt; \n  list_rbind(names_to = \"station_name\")\n\n結果は回りくどく書いたコードと同じです。\n最後に、より複雑な条件でのデータ取得を行う例を示します。 対象の気象観測所は4地点、対象の月が7月から9月までの3ヶ月分を取得します。つまり12パターンの組みあわせが必要になる処理を実行します。\n\ncrossing(month = seq.int(7, 9),\n         block_no = c(\"47895\", \"47891\", \"47887\", \"47893\")) |&gt; \n  purrr::pmap(\n    function(block_no, month) {\n      jma_collect(item = \"daily\",\n                  block_no = block_no,\n                  year = 2022,\n                  month = month)\n    }\n  )\n\nコードが複雑になればなるほど、purrrパッケージを使う利点が明確になります。"
  },
  {
    "objectID": "sessions/04_advanced.html#気象庁のデータ取得",
    "href": "sessions/04_advanced.html#気象庁のデータ取得",
    "title": "Advanced",
    "section": "",
    "text": "install.packages('jmastats', repos = c('https://uribo.r-universe.dev', 'https://cloud.r-project.org'))\n\n\nlibrary(jmastats)\n\n\ndata(stations, package = \"jmastats\")\n\njmastatsパッケージは日本の気象庁が提供する気象データをRから利用可能にするパッケージです。このパッケージを用いて、四国4県を代表する気象観測所4地点（徳島, 高松, 松山, 高知)での2023年7月の気象データを取得する場面を考えます。\njmastatsパッケージでは、jma_collect()関数を使って目的の気象データの取得を行います。その際、データの種類（ここでは2023年7月の日ごとの観測値が知りたいので”daily”を指定します）、取得対象の年月日、取得対象の気象観測所が位置するコード（block_no）を指定します。\n「徳島」のblock_noは”47895”なので、次のようにすると2023年7月の日ごとの気象データが取得されます。\n\njma_collect(item = \"daily\", block_no = \"47895\", year = 2023, month = 7)\n\nでは、対象の気象観測所を増やしてデータ取得を行いましょう。 まずは4地点の気象観測所のblock_noを調べる必要があります。 この処理は次のコードで実行します。\n\ndf_targets_st &lt;- \n  # jmastatsパッケージに含まれる気象観測所のデータ\n  stations |&gt; \n  # 1. 観測所の名前が同じで四国以外に位置する観測所を除外するため、\n  #    都道府県コードによる絞り込みを行う\n  filter(pref_code %in% as.character(seq.int(36, 39))) |&gt; \n  # 2. 四国県内で目的の気象観測所の名称で絞り込む\n  filter(station_name %in% c(\"徳島\", \"高松\", \"松山\", \"高知\")) |&gt; \n  # 3. 同一の気象観測所が複数行に分かれて記録されていることがあるのでユニークにする\n  distinct(block_no, station_name, pref_code)\n\n\ndf_targets_st\n\n\n\n\n\nblock_no\nstation_name\npref_code\n\n\n\n\n47895\n徳島\n36\n\n\n47891\n高松\n37\n\n\n47887\n松山\n38\n\n\n47893\n高知\n39\n\n\n\n\n\n\n対象の気象観測所のblock_noがわかったので、jma_collect()関数を使ってデータを取得しましょう。 先ほど示したコードのblock_no引数を変更するだけです。\n\njma_collect(item = \"daily\", block_no = \"47895\", year = 2023, month = 7)\njma_collect(item = \"daily\", block_no = \"47891\", year = 2023, month = 7)\njma_collect(item = \"daily\", block_no = \"47887\", year = 2023, month = 7)\njma_collect(item = \"daily\", block_no = \"47893\", year = 2023, month = 7)\n\nちょっと待ってください！ あなたが書こうと思いついたコードはどんなものですか？ もし、上に示したようにjma_collect()関数の引数block_no部分だけを変えることを考えていたのであれば、purrrパッケージを使ったコードに置き換えることが可能です。purrrパッケージを使うことで、jma_collect()関数の指定は1回で済み、コードも簡略化できます。\n\ndf_targets_st |&gt; \n  pluck(\"block_no\") |&gt; \n  map(\n    \\(x) jma_collect(item = \"daily\", block_no = x, year = 2023, month = 7)\n  )\n\n同じ関数を繰り返し記載したコードでは、どの引数が同じで、どの引数が違うのか注意を払う必要が生じます（例えば2023年7月の値を参照しているなかで、ある箇所だけが2020年8月と書いてしまうことがあるかもしれません）。map()関数ではそのような繰り返しの処理の引数の違いを心配することがなく、繰り返しの中での変更点だけに注意することができます。\n次に、取得した気象データを一つのデータフレームに格納することを考えましょう。その際、各データがどの気象観測所のものなのかわかるよう、station_name変数に気象観測所の名称を記録しておきます。この処理を回りくどく書くと次のようになります。\n\nbind_rows(\n  jma_collect(item = \"daily\", block_no = \"47895\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"徳島\", .before = 1),\n  jma_collect(item = \"daily\", block_no = \"47891\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"高松\", .before = 1),\n  jma_collect(item = \"daily\", block_no = \"47887\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"松山\", .before = 1),\n  jma_collect(item = \"daily\", block_no = \"47893\", year = 2023, month = 7) |&gt; \n    mutate(station_name = \"高知\", .before = 1))\n\n列を追加するmutate()関数も対象の気象観測所の数に応じて追加することになり、書かなければいけないコード量が増えてしまいました。\nmap()関数の返り値はリスト形式ですが、リストの中身がデータフレームである場合、それらを一つのデータフレームにまとめる関数list_rbind()が用意されています。また、便利なのがset_names()関数とlist_rbind()関数のnames_to引数を組み合わせることで、各データフレームに任意の列名と値を追加可能です。\n\ndf_targets_st |&gt; \n  pluck(\"block_no\") |&gt; \n  set_names(df_targets_st |&gt; \n              pluck(\"station_name\")) |&gt; \n  map(\n    \\(x) jma_collect(item = \"daily\", block_no = x, year = 2023, month = 7)\n  ) |&gt; \n  list_rbind(names_to = \"station_name\")\n\n結果は回りくどく書いたコードと同じです。\n最後に、より複雑な条件でのデータ取得を行う例を示します。 対象の気象観測所は4地点、対象の月が7月から9月までの3ヶ月分を取得します。つまり12パターンの組みあわせが必要になる処理を実行します。\n\ncrossing(month = seq.int(7, 9),\n         block_no = c(\"47895\", \"47891\", \"47887\", \"47893\")) |&gt; \n  purrr::pmap(\n    function(block_no, month) {\n      jma_collect(item = \"daily\",\n                  block_no = block_no,\n                  year = 2022,\n                  month = month)\n    }\n  )\n\nコードが複雑になればなるほど、purrrパッケージを使う利点が明確になります。"
  }
]